#include <assert.h>
#include <stdlib.h>
#include <ucontext.h>
#include "thread.h"
#include "interrupt.h"
 
#define READY 0
#define EXIT 1
 
/* This is the thread control block */
typedef struct thread {
    Tid thread_id; 
    int state; 
    ucontext_t threadContext; 
    void * stack_ptr; 
    struct thread * next; 
    struct wait_queue * wq;
}thread;
 
/* This is the wait queue structure */
typedef struct wait_queue {
    thread * WQ_head;
    int WQlength;
} wait_queue;
 
 
thread * ready_queue_head  = NULL;
thread * current_thread  = NULL;
thread * exit_queue_head  = NULL;
thread * thread_array[THREAD_MAX_THREADS];
wait_queue wq_array[THREAD_MAX_THREADS];
 
void
thread_stub(void (*thread_main)(void *), void *arg)
{
    interrupts_on();
    thread_main(arg); 
    thread_exit();
}
 
Tid get_next_thread_id(){
    int i = 0;
    for ( ; i < THREAD_MAX_THREADS; i++){
        if (! thread_array[i]){
            return i;
        }
    }
    return THREAD_NOMORE;
    if(!thread_array[THREAD_MAX_THREADS -1 ]){
        return THREAD_MAX_THREADS -1 ;
    }
 
}
 
thread * delete_from_ready_queue(Tid id){
    if (ready_queue_head == NULL){
        return NULL;
    }
    thread * temp = ready_queue_head;
    thread * prev = NULL;
    while (temp != NULL){
        if (temp->thread_id == id){
            if (temp == ready_queue_head){
                ready_queue_head = temp->next;
            }
            else {
                prev->next = temp->next;
            }
            temp->next = NULL;
            return temp;
        }
        prev = temp;
        temp = temp->next;
    }
    return NULL;
}
 
void
thread_init(void)
{
    
    
    for(int i=0; i< THREAD_MAX_THREADS; i++){
        thread_array[i] = NULL;
    }
    thread * first_thread  = (thread *)malloc(sizeof(thread));
    thread_array[0] = first_thread ;
    first_thread ->state = READY;
    first_thread ->next = NULL;
    first_thread ->stack_ptr = NULL;
    first_thread ->thread_id = 0;
    first_thread ->wq = &wq_array[0];
    first_thread ->wq->WQlength = 0;
    first_thread ->wq->WQ_head = NULL;
    current_thread  = first_thread ;
    getcontext(&first_thread ->threadContext);
 
}
 
Tid
thread_id()
{
    return current_thread ->thread_id;
}
 
Tid
thread_create(void (*fn) (void *), void *parg)
{
    int enabled = interrupts_off();
    thread * newthread  = (thread *)malloc(sizeof(thread));
    if (newthread  == NULL){
        free(newthread );
        interrupts_set(enabled);
        return THREAD_NOMEMORY;
    }
    if (get_next_thread_id() < 0){
        free(newthread);
        interrupts_set(enabled);
        return THREAD_NOMORE;
    }
    newthread ->thread_id = get_next_thread_id();
    thread_array[newthread ->thread_id] = newthread ;
    newthread ->next = NULL;
    newthread ->state = READY;
    newthread ->wq = &wq_array[newthread ->thread_id];
    newthread ->wq->WQ_head = NULL;
    newthread ->wq->WQlength = 0;
    newthread ->stack_ptr = (void *)malloc(THREAD_MIN_STACK);
    if (newthread ->stack_ptr == NULL){
        free(newthread ->stack_ptr);
        interrupts_set(enabled);
        return THREAD_NOMEMORY;
    }
    getcontext(&newthread ->threadContext);
    newthread ->threadContext.uc_mcontext.gregs[REG_RSP] = (unsigned long) (newthread->stack_ptr + THREAD_MIN_STACK - 8);
    newthread ->threadContext.uc_mcontext.gregs[REG_RBP] = (unsigned long) newthread->stack_ptr;
    newthread ->threadContext.uc_mcontext.gregs[REG_RDI] = (unsigned long) fn;
    newthread ->threadContext.uc_mcontext.gregs[REG_RSI] = (unsigned long) parg;
    newthread ->threadContext.uc_mcontext.gregs[REG_RIP] = (unsigned long) &thread_stub;
 
    struct thread* tmp = ready_queue_head;
        if (ready_queue_head == NULL){
            ready_queue_head = newthread;
        } else {
            while (tmp -> next != NULL)
                tmp = tmp -> next;
            tmp -> next = newthread;
        }
 
    int ret = newthread->thread_id;
    interrupts_set(enabled);
    return ret;
}
 
Tid
thread_yield(Tid tid)
{   
    int flag = 0;
    int enabled = interrupts_off();
    
    thread * ptr = exit_queue_head ;
    thread * next;
    while (ptr != NULL){
        next = ptr->next;
        
        thread_array[ptr->thread_id] = NULL;
        free(ptr->stack_ptr);
        ptr->stack_ptr = NULL;
        ptr->wq->WQ_head = NULL;
        ptr->wq->WQlength = 0;
        ptr->wq = NULL;
        free(ptr);
        ptr = next;
    }
    ptr = NULL;
    next = NULL;
    exit_queue_head  = NULL;
    
    if(thread_id() == tid){
        getcontext(&current_thread ->threadContext);
        if(flag == 0){
            flag = 1;
            setcontext(&current_thread ->threadContext);
        }
        interrupts_set(enabled);
        return current_thread ->thread_id;
    }else if(tid == THREAD_SELF) {
        getcontext(&current_thread ->threadContext);
        if(flag == 0){
            flag = 1;
            setcontext(&current_thread ->threadContext);
        }
        interrupts_set(enabled);
        return current_thread ->thread_id;
    }else if(tid == THREAD_ANY) {
        if (ready_queue_head == NULL){
            interrupts_set(enabled);
            return THREAD_NONE;
        }        
        thread * head = delete_from_ready_queue(ready_queue_head->thread_id);
        int current_thread_ID = head->thread_id;
        ///insert_to_ready_queue(current_thread );
         struct thread* tmp = ready_queue_head;
            if (ready_queue_head == NULL){
                ready_queue_head = current_thread;
            } else {
                while (tmp -> next != NULL)
                    tmp = tmp -> next;
                tmp -> next = current_thread;
            }
 
        flag = 0;
        getcontext(&current_thread ->threadContext);
        if (current_thread->state == EXIT){
            thread_exit();
        }
        if (flag == 0){
            flag = 1;
            current_thread  = head;
            setcontext(&head->threadContext);
        }
        interrupts_set(enabled);
        return current_thread_ID;
    }
    interrupts_set(enabled);
    return THREAD_INVALID;
}
 
void
thread_exit()
{
    int enabled = interrupts_off();
    thread_wakeup(&wq_array[current_thread ->thread_id], 1);
    if (ready_queue_head == NULL){
    
        thread * ptr = exit_queue_head ;
        thread * next;
        while (ptr != NULL){
            next = ptr->next;
        
            thread_array[ptr->thread_id] = NULL;
            free(ptr->stack_ptr);
            ptr->stack_ptr = NULL;
            ptr->wq->WQ_head = NULL;
            ptr->wq->WQlength = 0;
            ptr->wq = NULL;
            free(ptr);
            ptr = next;
        }
        ptr = NULL;
        next = NULL;
        exit_queue_head  = NULL;
 
 
        thread_array[current_thread ->thread_id] = NULL;
        current_thread ->wq->WQ_head = NULL;
        current_thread ->wq->WQlength = 0;
        current_thread ->wq = NULL;
        free(current_thread );
        current_thread  = NULL;
        interrupts_set(enabled);
        exit(0);
    }
    thread * next_thread = delete_from_ready_queue(ready_queue_head->thread_id);
    thread_array[current_thread ->thread_id] = NULL;
     struct thread* tmp = exit_queue_head;
            if (exit_queue_head == NULL){
                exit_queue_head = current_thread;
            } else {
                while (tmp -> next != NULL)
                    tmp = tmp -> next;
                tmp -> next = current_thread;
            }
 
    current_thread  = next_thread;
    setcontext(&current_thread ->threadContext);  
    interrupts_set(enabled);
}    
 
Tid
thread_kill(Tid tid)
{
    int enabled = interrupts_off();
    if (tid == current_thread ->thread_id || tid >= THREAD_MAX_THREADS){
        interrupts_set(enabled);
        return THREAD_INVALID;
    }else if(tid < 0 || thread_array[tid] == NULL){
        interrupts_set(enabled);
        return THREAD_INVALID;
    }
    thread_array[tid]->state = EXIT;
    thread * ptr = delete_from_ready_queue(tid);
    if (ptr == NULL){
        if (thread_array[tid] != NULL){
            thread_array[tid]->state = EXIT;
            thread_array[tid]->threadContext.uc_mcontext.gregs[REG_RIP] = (unsigned long) &thread_exit;
            interrupts_set(enabled);
            return tid;
        }
        interrupts_set(enabled);
        return THREAD_INVALID;
    }
    int ret;
    ret = ptr->thread_id;
    struct thread* tmp = exit_queue_head;
            if (exit_queue_head == NULL){
                exit_queue_head = ptr;
            } else {
                while (tmp -> next != NULL)
                    tmp = tmp -> next;
                tmp -> next = ptr;
            }
 
    interrupts_set(enabled);
    return ret;
}
 
/*******************************************************************
 * Important: The rest of the code should be implemented in Lab 3. *
 *******************************************************************/
 
/* make sure to fill the wait_queue structure defined above */
struct wait_queue *
wait_queue_create()
{
    wait_queue * wq;
    int enable = interrupts_off();
    wq = malloc(sizeof (wait_queue));
    assert(wq);
 
    interrupts_set(enable);
    return wq;
}
 
void
wait_queue_destroy(struct wait_queue *wq)
{
    int enable = interrupts_off();
    if (wq->WQ_head != NULL){
        thread_wakeup(wq, 1);
    }
    free(wq);
    interrupts_set(enable);
}
 
void insert_into_wait_queuw(thread * insert, wait_queue * queue){
    queue->WQlength = queue->WQlength + 1;
    if (queue->WQ_head == NULL){
        queue->WQ_head = insert;
        return;
    }
    thread * ptr = queue->WQ_head;
    while (ptr->next != NULL){
        ptr = ptr->next;
    }
    ptr->next = insert;
}
 
Tid
thread_sleep(struct wait_queue *queue)
{   
    int flag = 0;
    int enabled = interrupts_off();
    
    thread * ptr = exit_queue_head ;
    thread * next;
    while (ptr != NULL){
        next = ptr->next;
        
        thread_array[ptr->thread_id] = NULL;
        free(ptr->stack_ptr);
        ptr->stack_ptr = NULL;
        ptr->wq->WQ_head = NULL;
        ptr->wq->WQlength = 0;
        ptr->wq = NULL;
        free(ptr);
        ptr = next;
    }
    ptr = NULL;
    next = NULL;
    exit_queue_head  = NULL;
 
 
    if (queue == NULL){
        interrupts_set(enabled);
        return THREAD_INVALID;
    }else if (ready_queue_head == NULL){
        interrupts_set(enabled);
        return THREAD_NONE;
    }else{
        int current_threadID;
        thread * temp = delete_from_ready_queue(ready_queue_head->thread_id);
        current_threadID = temp->thread_id; 
        insert_into_wait_queuw(current_thread , queue);
        
        flag = 0;
        getcontext(&current_thread->threadContext);
        if (current_thread->state == EXIT){
            thread_exit();
        }
        if (thread_array[current_threadID] == NULL){
            interrupts_set(enabled);
            return current_threadID;
        }
        if (flag == 0){
            flag = 1;
            current_thread = temp;
            setcontext(&temp->threadContext);
        }
        interrupts_set(enabled);
        return current_threadID;
    }
    interrupts_set(enabled);
    return THREAD_INVALID;
}
 
/* when the 'all' parameter is 1, wakeup all threads waiting in the queue.
 * returns whether a thread was woken up on not. */
int
thread_wakeup(struct wait_queue *queue, int all)
{
    int enabled = interrupts_off();
    if (queue == NULL){
        interrupts_set(enabled);
        return 0;
    }
    if(queue->WQ_head == NULL){
        interrupts_set(enabled);
        return 0;
    } 
    if (all){
        int count = 0;
        thread* temp;
        thread* tmp;
        while (queue ->WQ_head != NULL){
            temp = queue -> WQ_head;
            queue -> WQ_head = queue -> WQ_head -> next;
            temp -> next = NULL;
 
            tmp = ready_queue_head;
            if (ready_queue_head == NULL){
                ready_queue_head = temp;
            } else {
                while (tmp -> next != NULL)
                    tmp = tmp -> next;
                tmp -> next = temp;
            }
            count++;
        }
        queue->WQ_head = NULL;
        queue->WQlength = 0;
        interrupts_set(enabled);
        return count;
    }
    if (!all){
        queue->WQlength = queue->WQlength - 1;
        thread * temp  = queue->WQ_head;
        queue->WQ_head = queue->WQ_head->next;
        temp ->next = NULL;
        struct thread* tmp = ready_queue_head;
        if (ready_queue_head == NULL){
            ready_queue_head = temp;
        } else {
            while (tmp -> next != NULL)
                tmp = tmp -> next;
            tmp -> next = temp;
        }
 
        interrupts_set(enabled);
        return 1;
    }
    interrupts_set(enabled);
    return 0;
}
 
Tid
thread_wait(Tid tid)
{
    int enabled = interrupts_off();
    if (tid == current_thread->thread_id || thread_array[tid] == NULL){
        interrupts_set(enabled);
        return THREAD_INVALID;
    }
 
    if(tid < 0 || tid >= THREAD_MAX_THREADS){
        interrupts_set(enabled);
        return THREAD_INVALID;
    }else {
        thread_sleep(&wq_array[tid]);
       
        thread * next;
        thread * ptr = exit_queue_head ;
        while (ptr != NULL){
        next = ptr->next;
        
        thread_array[ptr->thread_id] = NULL;
        free(ptr->stack_ptr);
        ptr->stack_ptr = NULL;
        ptr->wq->WQ_head = NULL;
        ptr->wq->WQlength = 0;
        ptr->wq = NULL;
        free(ptr);
        ptr = next;
    }
        ptr = NULL;
        next = NULL;
        exit_queue_head  = NULL;
        interrupts_set(enabled);
        return tid;
    }
}
 
struct lock {
    /* ... Fill this in ... */
    wait_queue * WQqueue;
    int holdlock;
};
 
struct lock *
lock_create()
{
    int enabled = interrupts_off();
    struct lock * lock;
 
    lock = malloc(sizeof(struct lock));
    assert(lock);
 
    lock->WQqueue = wait_queue_create();
    lock->holdlock = 0;
    interrupts_set(enabled);
    return lock;
}
 
void
lock_destroy(struct lock *lock)
{
    int enabled = interrupts_off();
    assert(lock != NULL);
    wait_queue_destroy(lock->WQqueue);
    free(lock);
    interrupts_set(enabled);
}
 
void
lock_acquire(struct lock *lock)
{
    assert(lock != NULL);
    int enabled = interrupts_off();
    while(lock->holdlock == 1){
        thread_sleep(lock->WQqueue);
    }
    lock->holdlock = 1;
    interrupts_set(enabled);
}
 
void
lock_release(struct lock *lock)
{
    assert(lock != NULL);
    int enabled = interrupts_off();
    lock->holdlock = 0;
    thread_wakeup(lock->WQqueue, 1);
    interrupts_set(enabled);
}
 
struct cv {
    /* ... Fill this in ... */
    wait_queue *  WQqueue;
};
 
struct cv *
cv_create()
{
    int enable = interrupts_off();
    struct cv *cv;
 
    cv = malloc(sizeof(struct cv));
    assert(cv);
 
    cv->WQqueue = wait_queue_create();
    interrupts_set(enable);
    return cv;
}
 
void
cv_destroy(struct cv *cv)
{
    int enable = interrupts_off();
    assert(cv != NULL);
    wait_queue_destroy(cv->WQqueue);
    free(cv);
    interrupts_set(enable);
}
 
void
cv_wait(struct cv *cv, struct lock *lock)
{
    int enable = interrupts_off();
    assert(cv != NULL);
    assert(lock != NULL);
    lock_release(lock);
    thread_sleep(cv->WQqueue);
    lock_acquire(lock);
    interrupts_set(enable);
}
 
void
cv_signal(struct cv *cv, struct lock *lock)
{
    int enable = interrupts_off();
    assert(cv != NULL);
    assert(lock != NULL);
    thread_wakeup(cv->WQqueue, 0);
    interrupts_set(enable);
}
 
void
cv_broadcast(struct cv *cv, struct lock *lock)
{
    int enable = interrupts_off();
    assert(cv != NULL);
    assert(lock != NULL);
    thread_wakeup(cv->WQqueue, 1);
    interrupts_set(enable);
 
}

